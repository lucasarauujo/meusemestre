const Quiz = require('../models/Quiz');
const Question = require('../models/Question');
const questionService = require('./questionService');
const fs = require('fs').promises;
const path = require('path');

const QUIZZES_FILE = path.join(__dirname, '..', 'quizzes.json');

class QuizService {
  constructor() {
    this.useDatabase = false;
  }

  // Expor m√©todo readFromJSON para uso em outros servi√ßos
  async readFromJSON() {
    try {
      const data = await fs.readFile(QUIZZES_FILE, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      if (error.code === 'ENOENT') {
        return [];
      }
      throw error;
    }
  }

  // Inicializa o servi√ßo e verifica se pode usar MongoDB
  async initialize() {
    try {
      if (Quiz && Quiz.db && Quiz.db.readyState === 1) {
        this.useDatabase = true;
        console.log('üìä QuizService: Usando MongoDB');
        await this.migrateFromJSON();
      } else {
        console.log('üìÑ QuizService: Usando arquivos JSON');
      }
    } catch (error) {
      console.log('üìÑ QuizService: Fallback para JSON devido a erro:', error.message);
    }
  }

  // Migra dados do JSON para MongoDB (apenas uma vez)
  async migrateFromJSON() {
    try {
      const count = await Quiz.countDocuments();
      if (count > 0) return; // J√° tem dados no banco

      const jsonData = await this.readFromJSON();
      if (jsonData.length === 0) return;

      console.log(`üîÑ Migrando ${jsonData.length} question√°rios do JSON para MongoDB...`);
      
      // Precisa mapear os IDs das quest√µes do JSON para ObjectIds do MongoDB
      const allQuestions = await Question.find().lean();
      
      for (const item of jsonData) {
        // Mapeia questionIds do formato string para ObjectIds
        const mappedQuestionIds = [];
        
        for (const oldQuestionId of item.questionIds) {
          // Busca a quest√£o que tinha esse ID no JSON
          const questions = await questionService.readFromJSON();
          const oldQuestion = questions.find(q => q.id === oldQuestionId);
          
          if (oldQuestion) {
            // Encontra a quest√£o correspondente no MongoDB pelo conte√∫do
            const mongoQuestion = allQuestions.find(q => 
              q.enunciado === oldQuestion.enunciado && 
              q.materia === oldQuestion.materia
            );
            
            if (mongoQuestion) {
              mappedQuestionIds.push(mongoQuestion._id);
            }
          }
        }

        if (mappedQuestionIds.length > 0) {
          const quiz = new Quiz({
            titulo: item.titulo,
            descricao: item.descricao,
            materia: item.materia,
            questionIds: mappedQuestionIds,
            tempoEstimado: item.tempoEstimado,
            instrucoes: item.instrucoes
          });
          
          // Preserva as datas originais
          if (item.createdAt) quiz.createdAt = new Date(item.createdAt);
          if (item.updatedAt) quiz.updatedAt = new Date(item.updatedAt);
          
          await quiz.save();
        }
      }
      
      console.log('‚úÖ Migra√ß√£o de question√°rios conclu√≠da!');
    } catch (error) {
      console.error('‚ùå Erro na migra√ß√£o de question√°rios:', error);
    }
  }



  // Salva dados no arquivo JSON
  async saveToJSON(quizzes) {
    await fs.writeFile(QUIZZES_FILE, JSON.stringify(quizzes, null, 2));
  }

  // ===== M√âTODOS P√öBLICOS =====

  async getAllQuizzes() {
    if (this.useDatabase) {
      const quizzes = await Quiz.find()
        .populate('questionIds', 'materia enunciado')
        .sort({ createdAt: -1 })
        .lean();
      
      // Transformar o resultado para garantir IDs como strings
      return quizzes.map(quiz => ({
        ...quiz,
        id: quiz._id.toString(),
        _id: quiz._id.toString()
      }));
    } else {
      const quizzes = await this.readFromJSON();
      return quizzes.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    }
  }

  async getQuizById(id) {
    if (this.useDatabase) {
      // Garantir que o ID seja uma string v√°lida antes de usar
      let quizId;
      if (typeof id === 'object' && id._id) {
        quizId = id._id.toString();
      } else if (typeof id === 'object' && id.id) {
        quizId = id.id.toString();
      } else {
        quizId = String(id).trim();
      }
      
      // Verificar se √© um ObjectId v√°lido
      if (!quizId || quizId.length !== 24 || !/^[a-fA-F0-9]{24}$/.test(quizId)) {
        console.error('ID de quiz inv√°lido:', { original: id, processed: quizId });
        return null;
      }
      
      const quiz = await Quiz.findById(quizId).lean();
      
      if (!quiz) return null;
      
      // Buscar quest√µes relacionadas manualmente
      const questions = await Question.find({ 
        _id: { $in: quiz.questionIds } 
      }).lean();
      
      return {
        ...quiz,
        id: quiz._id.toString(),
        questions: questions // Quest√µes completas para execu√ß√£o
      };
    } else {
      const quizzes = await this.readFromJSON();
      const quiz = quizzes.find(q => q.id === id);
      
      if (!quiz) return null;

      // Buscar as quest√µes do question√°rio
      const questions = await questionService.getAllQuestions();
      const quizQuestions = questions.filter(q => quiz.questionIds.includes(q.id));
      
      return {
        ...quiz,
        questions: quizQuestions
      };
    }
  }

  async createQuiz(quizData) {
    if (this.useDatabase) {
      // Converte string IDs para ObjectIds e verifica se as quest√µes existem
      const objectIds = quizData.questionIds.map(id => {
        if (typeof id === 'string' && id.length === 24) {
          return id;
        }
        throw new Error(`ID de quest√£o inv√°lido: ${id}`);
      });

      const validQuestions = await Question.find({ 
        _id: { $in: objectIds } 
      });

      if (validQuestions.length !== objectIds.length) {
        console.log('IDs enviados:', objectIds);
        console.log('Quest√µes encontradas:', validQuestions.map(q => q._id));
        throw new Error(`Algumas quest√µes n√£o foram encontradas. Esperadas: ${objectIds.length}, Encontradas: ${validQuestions.length}`);
      }

      const quiz = new Quiz({
        ...quizData,
        questionIds: objectIds
      });
      const savedQuiz = await quiz.save();
      
      // Retornar com IDs como strings para consist√™ncia
      return {
        ...savedQuiz.toObject(),
        id: savedQuiz._id.toString(),
        _id: savedQuiz._id.toString()
      };
    } else {
      const quizzes = await this.readFromJSON();
      
      // Verificar se as quest√µes existem
      const questions = await questionService.getAllQuestions();
      const validQuestionIds = quizData.questionIds.filter(id => 
        questions.some(q => q.id === id)
      );

      if (validQuestionIds.length !== quizData.questionIds.length) {
        throw new Error('Algumas quest√µes n√£o foram encontradas');
      }
      
      const newQuiz = {
        id: Date.now().toString(),
        titulo: quizData.titulo.trim(),
        descricao: quizData.descricao?.trim() || '',
        materia: quizData.materia?.trim() || '',
        questionIds: validQuestionIds,
        tempoEstimado: quizData.tempoEstimado || 30,
        instrucoes: quizData.instrucoes?.trim() || '',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      quizzes.push(newQuiz);
      await this.saveToJSON(quizzes);
      return newQuiz;
    }
  }

  async updateQuiz(id, quizData) {
    if (this.useDatabase) {
      // Converte string IDs para ObjectIds e verifica se as quest√µes existem
      let transformedData = { ...quizData };
      
      if (quizData.questionIds) {
        const objectIds = quizData.questionIds.map(qId => {
          if (typeof qId === 'string' && qId.length === 24) {
            return qId;
          }
          throw new Error(`ID de quest√£o inv√°lido: ${qId}`);
        });

        const validQuestions = await Question.find({ 
          _id: { $in: objectIds } 
        });

        if (validQuestions.length !== objectIds.length) {
          throw new Error('Algumas quest√µes n√£o foram encontradas');
        }

        transformedData.questionIds = objectIds;
      }

      transformedData.updatedAt = new Date();

      const updatedQuiz = await Quiz.findByIdAndUpdate(
        id, 
        transformedData,
        { new: true, runValidators: true }
      );
      
      if (!updatedQuiz) return null;
      
      // Retornar com IDs como strings para consist√™ncia
      return {
        ...updatedQuiz.toObject(),
        id: updatedQuiz._id.toString(),
        _id: updatedQuiz._id.toString()
      };
    } else {
      const quizzes = await this.readFromJSON();
      const quizIndex = quizzes.findIndex(q => q.id === id);
      
      if (quizIndex === -1) {
        throw new Error('Question√°rio n√£o encontrado');
      }

      // Verificar se as quest√µes existem
      if (quizData.questionIds) {
        const questions = await questionService.getAllQuestions();
        const validQuestionIds = quizData.questionIds.filter(id => 
          questions.some(q => q.id === id)
        );

        if (validQuestionIds.length !== quizData.questionIds.length) {
          throw new Error('Algumas quest√µes n√£o foram encontradas');
        }
      }

      quizzes[quizIndex] = {
        ...quizzes[quizIndex],
        titulo: quizData.titulo.trim(),
        descricao: quizData.descricao?.trim() || '',
        materia: quizData.materia?.trim() || '',
        questionIds: quizData.questionIds || quizzes[quizIndex].questionIds,
        tempoEstimado: quizData.tempoEstimado || 30,
        instrucoes: quizData.instrucoes?.trim() || '',
        updatedAt: new Date().toISOString()
      };

      await this.saveToJSON(quizzes);
      return quizzes[quizIndex];
    }
  }

  async deleteQuiz(id) {
    if (this.useDatabase) {
      const result = await Quiz.findByIdAndDelete(id);
      return !!result;
    } else {
      const quizzes = await this.readFromJSON();
      const filteredQuizzes = quizzes.filter(q => q.id !== id);
      
      if (filteredQuizzes.length === quizzes.length) {
        return false; // N√£o encontrou
      }

      await this.saveToJSON(filteredQuizzes);
      return true;
    }
  }
}

module.exports = new QuizService();
